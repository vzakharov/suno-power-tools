(()=>{function f(t){return typeof t=="function"}function d(t){return f(t)?new r(t):new o(t)}var i=class{constructor(e){this._value=e}watchers=[];activeWatchers=new WeakSet;get(){return u?.(this),this._value}_set(e){let{_value:n}=this;if(e!==this._value){this._value=e;try{for(let s of this.watchers){if(this.activeWatchers.has(s)){console.warn("smork: watcher is already active \u2014 perhaps a circular dependency \u2014 exiting watch to prevent infinite loop");return}this.activeWatchers.add(s),s(e,n)}}finally{this.activeWatchers=new WeakSet}}}runAndWatch(e){e(this._value,this._value),this.watch(e)}watchImmediate=this.runAndWatch;watch(e){this.watchers.push(e)}onChange=this.watch;unwatch(e){this.watchers=this.watchers.filter(n=>n!==e)}get value(){return this.get()}map(e){return new r(()=>e(this.value))}},o=class extends i{set(e){this._set(e)}set value(e){this.set(e)}get value(){return this.get()}};var u,r=class extends o{constructor(e){if(u)throw new Error("smork: currentComputedPreHandler is already set (this should never happen)");try{u=n=>{n.watch(()=>this._set(e()))},super(e())}finally{u=void 0}}},a=class extends o{constructor(n,s){let T=new r(n);super(T.value);this.setter=s;T.watch(h=>this._set(h))}set(n){if(this.setter(n),this.value!==n)throw new Error("smork: bridge value did not change to the one being set")}};function c(t){return new r(t)}function l(t){return c(()=>!t.value)}function p(t,e){Object.assign(t,e)}p(window,{ref:d,computed:c,useNot:l,BaseRef:i,Ref:o,ComputedRef:r,BridgedRef:a});})();

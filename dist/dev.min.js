(vovas = { main() {
(()=>{function x(n,e){return Object.fromEntries(Object.entries(n).map(([t,r])=>[t,e(r,t)]))}function c(n){return typeof n=="function"}function h(n,e){return Object.assign(n,e)}function m(n,e){Object.assign(n,e)}function y(n){return e=>e===n}var d=class extends Error{constructor(e){super(`smork: ${e}`)}};function R(n,e){return c(n)?T(n,e):new a(n)}var i=class{constructor(e){this._value=e}watchers=new Set;activeWatchers=new WeakSet;get(){return f?.(this),this._value}_set(e){let{_value:t}=this;if(e!==this._value){this._value=e;try{for(let r of this.watchers){if(this.activeWatchers.has(r)){console.warn("smork: watcher is already active \u2014 perhaps a circular dependency \u2014 exiting watch to prevent infinite loop");return}this.activeWatchers.add(r),r(e,t)}}finally{this.activeWatchers=new WeakSet}}}runAndWatch(e){e(this._value,this._value),this.watch(e)}watchImmediate=this.runAndWatch;watch(e){this.watchers.add(e)}onChange=this.watch;unwatch(e){this.watchers.delete(e)}get value(){return this.get()}map(e){let t=new p(this,e);return c(t.value)?(this.unwatch(t.update),(...r)=>new p(this,s=>e(s)(...r))):t}if(e,t,r){return this.map(s=>(c(e)?e:y(e))(s)?t(s):r(s))}merge(e){return e?T(()=>({...this.value,...w(e)})):this}uses(e){return h(this,x(e,this.map))}},p=class extends i{constructor(t,r){var e=(..._)=>(super(..._),this.dependency=t,this.mapper=r,this);t&&(e(r(t.value)),t.watch(this.update))}update=t=>this._set(this.mapper(t))},a=class extends i{set(e){this._set(e)}set value(e){this.set(e)}get value(){return this.get()}bridge(e,t){return new u(()=>e(this.value),r=>this.set(t(r)))}};var f,o=class extends a{constructor(t){super(void 0);this.getter=t;this.track()}dependencies=new Set;track=()=>{if(f)throw new d("Tried to compute a ref while another one is already being computed \u2014 did you nest a computed ref in another ref's getter function?");this.dependencies.forEach(t=>t.unwatch(this.track)),this.dependencies=new Set;try{f=t=>{t.watch(this.track),this.dependencies.add(t)},this._set(this.getter())}finally{f=void 0}}},u=class extends a{constructor(t,r,s=!1){let l=new o(t);super(l.value);this.setter=r;this.allowMismatch=s;l.watch(v=>this._set(v))}set(t){if(this.setter(t),!this.allowMismatch&&this.value!==t)throw new d("Setter did not update the value. If you want to allow this, set the allowMismatch property to true.")}};function T(n,e){return e?new u(n,e):new o(n)}function g(n){return T(()=>!n.value)}function U(n){return(e,t)=>n instanceof i?e(n):t(n)}function w(n){return U(n)(e=>e.value,e=>e)}m(window,{ref:R,computed:T,useNot:g,Ref:i,WritableRef:a,ComputedRef:o,WritableComputedRef:u});})();
}}).main();

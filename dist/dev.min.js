(vovas = { main() {
(()=>{function T(e){return typeof e=="function"}function I(e,t){return Math.max(...[...e].map(t))}var Ke=Symbol("NOT_SET");function p(e){return e!==void 0}function B(e){return e}function _(e){return[e]}var Me=Symbol("brand");function h(e,t){return T(e)?e(t):e}function k(){return null}function K(...e){return e.pop()(...e)}function se(e,t){Object.assign(e,t)}function de(e,t){return se(e,t),e}function s(e){throw e instanceof Error?e:new Error(e)}function D(e,t){return t(e),e}function G(e){return new Promise(t=>{setTimeout(()=>{t(e?.())},0)})}function M(e,t,n){if(e.has(t))return e.get(t);let o=h(n,t);return e.set(t,o),o}function Y(...[e,t]){if(T(e))return n(e,t);{let o=e;return n(()=>o,r=>o=r)}function n(o,r){return function a(u){if(u===void 0)return o();if(!r)throw new TypeError("Cannot set value on a read-only box");return T(u)?a(u(o())):(r(u),u)}}}function x(...e){return Y(...e)}function ce(e){let t=new WeakMap;return n=>M(t,n,()=>e(n))}function le(e){let t=ce(o=>{let[r,a]=e(o);return Y(r,a)});function n(o,r){return p(r)?t(o)(r):t(o)()}return n}function i(e){return le(t=>[e(t)])}function z(e){return e+1}var j=Symbol("typeMarker");function y(e,t){return de(t,{[j]:e})}function R(e){return function(n){return n&&["object","function"].includes(typeof n)&&j in n&&n[j]===e}}function E(e,t){return n=>e(n)||t(n)}var pe=Symbol("BREAK"),f=class{set=new Set;*iterator(){for(let t of this.set){let n=t.deref();n?yield[n,t]:this.set.delete(t)}}add(t){return this.set.add(new WeakRef(t)),this}has(t){for(let n of this)if(n===t)return!0;return!1}clear(){this.set.clear()}delete(t){for(let[n,o]of this.iterator())if(n===t)return this.set.delete(o),!0;return!1}get size(){return[...this].length}forEach(t){for(let n of this)if(t(n)===pe)break}map(t){return[...this].map(t)}[Symbol.iterator](){return function*(){for(let[t]of this.iterator())yield t}.call(this)}};function A(){let e=new WeakMap;function t(...o){return n(...o)}function n(o,r,a){let u=M(e,o,new f);return r===null?u.forEach(S=>n(S,o,null)):r&&[[u,r],[M(e,r,new f),o]].forEach(([S,O])=>a===null?S.delete(O):S.add(O)),[...u]}return t}var xe=0,H=i(e=>xe++),g=new f,Q=Symbol("RootRef");function F(e){let t=$(y(Q,x(()=>(ie(t),ye(t),e),n=>{e!==n&&(m(t,!0),p(e)&&P(t,e),[t,...d(t)].forEach(ge),e=n,H(t,z))})));return g.add(t),t}var C=R(Q),b=new Set,d=A(),q=i(e=>0),X=i(e=>({source:k()})),Z=Symbol("ReadonlyComputedRef");function ye(e){b.forEach(t=>{let{source:n}=X(t);(!n||C(n)?n===e:b.has(n))&&d(t,e)})}function U(e,t){let n=B(),o=$(y(Z,x(()=>{if(ie(o),n===void 0||K(I(d(o),H),r=>{if(r>q(o))return q(o,r),!0})){d(o,null),b.add(o);try{n=D(e(),r=>m(o,D(n!==r,a=>a&&p(n)&&P(o,n))))}finally{b.delete(o)}}else b.forEach(r=>{d(o).forEach(a=>{d(r,a)})});return n})));return t&&X(o,{source:t}),g.add(o),o}var Re=R(Z),ee=Symbol("WritableComputedRef");function te(e,t,n){let o=$(y(ee,x(U(e,n),t)));return g.add(o),o}var ne=R(ee),be=E(Re,ne),oe=E(C,be),re=E(C,ne);function me(e,t){return t?te(e,t):U(e)}var N=new f,c=A(),ae=i(e=>({source:k()})),ue=Symbol("Effect"),l=[],J=x(_(0)),ve=i(e=>new Set),m=i(e=>k()),P=i(e=>B()),V=new WeakSet,L=new WeakSet;function W(e,t){let n=y(ue,o=>{if(L.has(n))throw"This effect has been destroyed and cannot be used anymore.";if(o===0){V.add(n);return}else if(o===1)V.delete(n);else if(o===-1){c(n,null),L.add(n);return}t?ae(n,{source:t}):(c(n).forEach(r=>m(r,null)),c(n,null)),l.push(n);try{t?e(t(),P(t)):e()}finally{let r=l.pop();r!==n&&console.warn("Effect stack mismatch:",{effect:n,lastEffect:r,effectStack:l})}});return t?c(n,t):n(),N.add(n),n}var et=R(ue);function ie(e){K(l.at(-1),t=>t&&!ae(t).source&&c(t,e))}function ge(e){(C(e)||K(m(e),t=>t===null?(e(),m(e)??s("valueChanged not updated")):t))&&c(e).forEach(t=>{if(V.has(t))return;if(l.includes(t)){console.warn("Circular effect detected, ignoring effect to prevent infinite loop:",{effect:t,effectStack:l});return}let n=J(),o=ve(n);o.size||G(()=>{J(([r])=>[r+1]),o.forEach(h)}),o.add(t)})}function Ue(e,t,n){return n?te(()=>t(e()),re(e)?o=>e(n(o)):s("Cannot use a backMapper with a readonly ref."),e):U(()=>t(e()),e)}function v(e,t,n){return oe(e)?Ue(e,t??s("A mapper function must be provided when the first argument is a ref."),n):T(e)?me(e,t):F(e)}var Te=v;function w(e,t){return oe(e)?W(t??s("A callback must be provided when the first argument is a ref."),e):W(e)}var fe=w;function Se(e){function t(n,o){return o?re(e)?v(e,n,o):s("Cannot use a backMapper with a readonly ref."):v(e,n)}return{to:t,watch:n=>w(e,n)}}function $(e){return Object.assign(e,Se(e))}Object.assign(window,{RootRef:F,ReadonlyComputedRef:U,Effect:W,Ref:v,ref:Te,effect:fe,watch:w,allRefs:g,allEffects:N});})();
}}).main();

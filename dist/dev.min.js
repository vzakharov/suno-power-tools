(vovas = { main() {
(()=>{function y(t,e){return Object.fromEntries(Object.entries(t).map(([n,r])=>[n,e(r,n)]))}function u(t){return typeof t=="function"}function m(t){return t}function R(t,e){return Object.assign(t,e)}function g(t,e){Object.assign(t,e)}function v(t){return e=>e===t}var p=class extends Error{constructor(e){super(`smork: ${e}`)}};function U(t,e){return u(t)?T(t,e):new a(t)}var i=class{constructor(e){this._value=e}watchers=new Set;activeWatchers=new WeakSet;get(){return d?.(this),this._value}_set(e){let{_value:n}=this;if(e!==this._value){this._value=e;try{for(let r of this.watchers){if(this.activeWatchers.has(r)){console.warn("smork: watcher is already active \u2014 perhaps a circular dependency \u2014 exiting watch to prevent infinite loop");return}this.activeWatchers.add(r),r(e,n)}}finally{this.activeWatchers=new WeakSet}}}runAndWatch(e){e(this._value,this._value),this.watch(e)}watchImmediate=this.runAndWatch;watch(e){this.watchers.add(e)}onChange=this.watch;unwatch(e){this.watchers.delete(e)}get value(){return this.get()}map(e){let n=new l(this,e);return u(n.value)?(this.unwatch(n.update),(...r)=>new l(this,c=>e(c)(...r))):n}if(e,n,r){let[c,f,x]=r?u(e)?[e,n,r]:[v(e),n,r]:[m,e,n];return this.map(h=>c(h)?f(h):x(h))}merge(e){return e?T(()=>({...this.value,...b(e)})):this}uses(e){return R(this,y(e,this.map))}},l=class extends i{constructor(n,r){var e=(...j)=>(super(...j),this.dependency=n,this.mapper=r,this);n&&(e(r(n.value)),n.watch(this.update))}update=n=>this._set(this.mapper(n))},a=class extends i{set(e){this._set(e)}set value(e){this.set(e)}get value(){return this.get()}bridge(e,n){return new s(()=>e(this.value),r=>this.set(n(r)))}};var d,o=class extends a{constructor(n){super(void 0);this.getter=n;this.track()}dependencies=new Set;track=()=>{if(d)throw new p("Tried to compute a ref while another one is already being computed \u2014 did you nest a computed ref in another ref's getter function?");this.dependencies.forEach(n=>n.unwatch(this.track)),this.dependencies=new Set;try{d=n=>{n.watch(this.track),this.dependencies.add(n)},this._set(this.getter())}finally{d=void 0}}},s=class extends a{constructor(n,r,c=!1){let f=new o(n);super(f.value);this.setter=r;this.allowMismatch=c;f.watch(x=>this._set(x))}set(n){if(this.setter(n),!this.allowMismatch&&this.value!==n)throw new p("Setter did not update the value. If you want to allow this, set the allowMismatch property to true.")}};function T(t,e){return e?new s(t,e):new o(t)}function w(t){return T(()=>!t.value)}function K(t){return(e,n,r)=>t instanceof i?e(t):u(t)?n(t):r(t)}function b(t){return K(t)(e=>e.value,e=>e(),e=>e)}g(window,{ref:U,computed:T,useNot:w,BaseRef:i,Ref:a,ComputedRef:o,WritableComputedRef:s});})();
}}).main();
